/*
 - 비동기 처리
   [동기 vs 비동기 ]
    - 동기: 요청을 보낸 후 해당 응답을 받아야 다음 동작을 실행(ex 은행)

    - 비동기: 요청을 보낸 후 응답에 관계없이 다음 동작을 실행(ex 카페)

  [비동기 처리]
   : 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고, 순차적으로 
     다음 코드를 먼저 실행하는 자바스크립트의 특성(싱글 스레드, 콜스택).

     클라이언트에서 서버로 데이터를 요청 했을 때, 서버가 그 요청에 대한 응답을 
     언제 줄지도 모르는데 마냥 기다릴 수 없어 비동기처리가 필요!
     (즉시 처리하지 못하는 이벤트들을 Web API를 이용하여 큐로 보내서 이벤트
      루프를 통해 콜스택이 비었을 경우 실행)

*/
if(false){
    function work() {
      const start = Date.now();
      for (let i = 0; i < 1000000000; i++) {}
      const end = Date.now();
      console.log(end - start + 'ms');
    }
    
    console.log('작업 시작!');
    work();
    console.log('다음 작업');

}
/*
    여기서 Date.now 는 현재 시간을 숫자 형태로 가져오는 자바스크립트 
    내장 함수이다. 위 work 함수는, 1,000,000,000 번 루프를 돌고, 이 작업이 
    얼마나 걸렸는지 알려준다.
*/  

/*
    지금은 work() 함수가 호출되면, for 문이 돌아갈 때는 다른 작업은 처리하지 
    않고 온전히 for 문만 실행한다.

    만약 이 작업이 진행되는 동안 다른 작업도 하고 싶다면 함수를 비동기 형태로 
    전환을 해줘야 하는데, 그렇게 하기 위해서는 setTimeout 이라는 함수를 
    사용해줘야한다.

    코드를 다음과 같이 수정해보자!
*/
if(true){

  function work() {
      setTimeout(() => {
        const start = Date.now();
        for (let i = 0; i < 1000000000; i++) {}
        const end = Date.now();
        console.log((end - start) + 'ms');
      }, 0);
    }
     
    console.log('작업 시작!');
    work();
    console.log('다음 작업');

}
/*
   setTimeout 함수는 첫번째 파라미터에 넣는 함수를 두번째 파라미터에 
   넣은 시간(ms 단위)이 흐른 후 호출해준다. 
   지금은 두번째 파라미터에 0을 넣었다. 따라서, 이 함수는 바로 실행이 된다. 
   0ms 이후에 실행한다는 의미이지만 실제로는 4ms 이후에 실행된다. 
   
   이렇게 setTimeout 을 사용하면 우리가 정한 작업이 백그라운드에서 수행되기 때문에
   기존의 코드 흐름을 막지 않고 동시에 다른 작업들을 진행 할 수 있다.
*/

/*
코드를 실행해보면, 작업이 시작 되고 나서, for 루프가 돌아가는 동안 다음 작업도 
실행되고, for 루프가 끝나고 나서 몇 ms 걸렸는지 보여준다.

그렇다면, 만약에 work 함수가 끝난 다음에 어떤 작업을 처리하고 싶다면 
어떻게 해야 할까? 이럴 땐, 콜백 함수를 파라미터로 전달해주면 된다. 

콜백 함수란, 함수 타입의 값을 파라미터로 넘겨줘서, 파라미터로 받은 함수를 
특정 작업이 끝나고 호출을 해주는 것을 의미한다.

*/
if(false){

   function work(cc) {
       setTimeout(() => {
         const start = Date.now();
         for (let i = 0; i < 1000000000; i++) {}
         const end = Date.now();
         console.log(end - start + 'ms');
         cc();
       }, 0);
     }
     
     console.log('작업 시작!');
     work(() => {
       console.log('작업이 끝남!')
     })
     console.log('다음 작업');
 }
  /*
  다음과 같은 작업들은 주로 비동기적으로 처리하게 된다.

  - Ajax Web API 요청: 만약 서버쪽에서 데이터를 받와아야 할 때는, 
    요청을 하고 서버에서 응답을 할 때 까지 대기를 해야 되기 때문에 
    작업을 비동기적으로 처리한다.

  - 파일 읽기: 주로 서버 쪽에서 파일을 읽어야 하는 상황에는 비동기
    적으로 처리한다.

  - 암호화/복호화: 암호화/복호화를 할 때에도 바로 처리가 되지 않고, 
    시간이 어느정도 걸리는 경우가 있기 때문에 비동기적으로 처리한다.
  
  - 작업 예약: 단순히 어떤 작업을 몇초 후에 스케쥴링 해야 하는 상황에는,
     setTimeout 함수를 사용하여 비동기적으로 처리한다.
     작업이 소유되는 시간은 0.016( 1초 / 60)초로 맞춰서 작업하는 것이
     성능면에서 효율적이다. 

    비동기 작업을 다룰 때에는 setTimeout 함수 외에도 Promise, async/await
    라는 문법을 사용하여 처리 할 수 있다. 
    
  */